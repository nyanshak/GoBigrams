/*
	Author: Brendan Shaklovitz

	Program: bigramTest
	Usage: bigramTest.exe -lm <lm input file> -text <input text file>
	
	reads Language Model (generated by bigramTrain) and input text and outputs perplexity
 */
package main

import (
	"fmt"
	"flag"
	"os"
	"bufio"
	"log"
	"strings"
	"strconv"
	"io/ioutil"
	"math"
)

var lm = flag.String("lm", "<lm>", "lm input file")
var text = flag.String("text", "<text_file>", "test input file")

func exists(path string) (bool, error) {
	_, err := os.Stat(path)
	if err == nil { return true, nil }
	if os.IsNotExist(err) { return false, nil }
	return false, err
}

var Usage = func() {
	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
}

type prob_pair struct {
	α_h, logprob float64
}

type bigram struct {
	word_one, word_two string
}

type Bigram []*bigram
// Methods required by sort.Interface.
func (s Bigram) Len() int {
	return len(s)
}
func (s Bigram) Less(i, j int) bool {
	if s[i].word_one < s[j].word_one {
		return true
	} else if s[i].word_one == s[j].word_one {
		return s[i].word_two < s[j].word_two
	}
	return false
}

func (s Bigram) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

func WordCount(s string) (map[string]int, int) {

	substrings := strings.Fields(s)
	wc := 0
	counts := make(map[string]int)

	for _, word := range substrings {
		wc++
		_, ok := counts[word]

		if ok == true {
			counts[word] += 1
		} else {
			counts[word] = 1
		}
	}

	return counts, wc
}

func BigramCount(counts map[bigram]int, s string) map[bigram]int {

	substrings := strings.Fields(s)

	for i := 0; i < len(substrings) - 1; i++ {
		temp_bigram := bigram{substrings[i], substrings[i + 1]}
		_, ok := counts[temp_bigram]

		if ok == true {
			counts[temp_bigram] += 1
		} else {
			counts[temp_bigram] = 1
		}
	}

	return counts
}

func main() {
	flag.Parse()

	if flag.NFlag() != 2 {
		flag.Usage()
		os.Exit(2)
	}
	fileExist, _ := exists(*lm)
	file2Exist, _ := exists(*text)
	if !fileExist || !file2Exist {
		flag.Usage()
		os.Exit(2)
	}

	unigrams_training := make(map[string]prob_pair)
	bigrams_training := make(map[bigram]float64)

	file, _ := os.Open(*lm)
	scanner := bufio.NewScanner(file)
	status := ""
	for scanner.Scan() {
		txt := scanner.Text()
		if (txt == "unigrams:"){
			status = "unigrams"
		} else if txt == "bigrams:" {
			status = "bigrams"
		} else if status == "unigrams" {

			s := strings.Fields(txt)
			word := s[1]
			α_h, e1 := strconv.ParseFloat(s[0], 64)
			logprob, e2 := strconv.ParseFloat(s[2], 64)

			if e1 != nil || e2 != nil {
				fmt.Println(e1, e2)
			} else {
				unigrams_training[word] = prob_pair{α_h, logprob}
			}
		} else {
			s := strings.Fields(txt)
			word1 := s[1]
			word2 := s[2]
			logprob, err := strconv.ParseFloat(s[0], 64)

			if err != nil {
				fmt.Println(err)
			} else {
				bg := bigram{word1, word2}
				bigrams_training[bg] = logprob
			}
		}
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	content, err := ioutil.ReadFile(*text)
	if err != nil {
		fmt.Println(err)
		os.Exit(2)
	}
	s := string(content)
	unigrams_count, wordCount := WordCount(s)

	unigrams_probability := make(map[string]float64)
	for key, value := range unigrams_count {
		unigrams_probability[key] = float64(value) / float64(wordCount)
	}

	bigrams_count := make(map[bigram]int)

	trainingFile, _ := os.Open(*text)
	scanner = bufio.NewScanner(trainingFile)
	for scanner.Scan() {
		bigrams_count = BigramCount(bigrams_count, scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	sum := float64(0)
	for key, value := range bigrams_count {
		training_val, found := bigrams_training[key]
		
		if found {
			sum += training_val * float64(value)
		} else {
			α_h := unigrams_training[key.word_one].α_h
			prob := α_h * float64(unigrams_count[key.word_two]) / float64(wordCount)
			sum += math.Log2(prob)
		}
	}

	exp := (-1.0 / float64(wordCount)) * sum
	perplexity := math.Pow(2.0, exp)

	fmt.Println("Perplexity:", perplexity)

}
